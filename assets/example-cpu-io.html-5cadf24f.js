import{_ as a,o as e,c as s,b as o}from"./app-a46f6870.js";const d={},p=o('<h1 id="cpu密集型与io密集型" tabindex="-1"><a class="header-anchor" href="#cpu密集型与io密集型" aria-hidden="true">#</a> cpu密集型与io密集型</h1><p>cpu密集型：大量计算 io密集型：大量输入/输出</p><p>CPU密集型本身就不适合nodejs，但非常适合大量io操作的情况。</p><p>假设一个请求流程是10ms的简单运算，生成sql语句，900ms的数据库查询并返回。90ms的数据数据并返回。完整时间是1s。</p><h2 id="java处理" tabindex="-1"><a class="header-anchor" href="#java处理" aria-hidden="true">#</a> java处理</h2><p>如果是1000个请求，不在考虑数据库压力的情况下，理论上java会并发产生1000个线程来处理，理论上也就可以在1s内处理完1000个请求并全部返回数据。</p><p>单位为了这1000个线程，服务器可能产生了百分之80的资源消耗。也就是说你这台服务器能支撑1000个并发已经很好了。</p><h2 id="nodejs处理" tabindex="-1"><a class="header-anchor" href="#nodejs处理" aria-hidden="true">#</a> nodejs处理</h2><p>如果1000个请求，从第一个请求开始，10ms处理完成，然后就交给数据去处理了，这个时候就可以处理下一个10ms的请求。也就是node服务需要10s才可以接收完所有的请求</p><p>但是第一个请求返回时间是1s，第二个请求返回时间是1s+10ms，以此类推，但是这1000个并发nodejs会在11s左右全部处理完。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>你可能觉得java是1s，nodejs是11s，差距很大，但是需要注意的是服务器消耗。</p><p>java是1000个进程可能已经是服务器的极限看了，但是nodejs服务器确一点事情都没有。</p><p>换而言之， 我一台服务器打开10个nodejs进程，我一台服务器就可以处理的并发是10s，1W的，但是java确是1s，1000</p><p>我需要用10台服务器才可以满足1W的并发。</p><p>实际工作中，我们会发现。在相同的业务需求下，io密集型的需求，使用nodejs同一台服务器可以处理的并发量更大，当然，牺牲了一部分的时间。但是这个完全可以用多开进程的方式来弥补来达到一个均衡。 同样的服务器，仅io密集型的需求而言，nodejs更加合适。</p><p>但是如果是cpu密集型的 你java开1000个线程，是并发计算的，一个计算1秒，1000的线程也1秒返回了，但是使用nodejs，你需要1000秒才可以返回。</p>',17),n=[p];function i(r,c){return e(),s("div",null,n)}const t=a(d,[["render",i],["__file","example-cpu-io.html.vue"]]);export{t as default};
