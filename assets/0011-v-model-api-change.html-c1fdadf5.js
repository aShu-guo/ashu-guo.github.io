import{_ as c,r as p,o as i,c as r,a,d as n,e as s,w as t,b as o}from"./app-a46f6870.js";const u={},d=a("h1",{id:"更改v-model-api",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#更改v-model-api","aria-hidden":"true"},"#"),n(" 更改v-model API")],-1),v=a("h2",{id:"概要",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#概要","aria-hidden":"true"},"#"),n(" 概要")],-1),k=a("p",null,"调整在自定义组件上v-model API的使用方式。",-1),m=a("code",null,"v-model",-1),h=a("code",null,"v-bind",-1),b=a("code",null,".sync",-1),g=o(`<h2 id="基础用例" tabindex="-1"><a class="header-anchor" href="#基础用例" aria-hidden="true">#</a> 基础用例</h2><p>N/A</p><h2 id="动机" tabindex="-1"><a class="header-anchor" href="#动机" aria-hidden="true">#</a> 动机</h2><p>在此之前，组件上的<code>v-model=&quot;foo&quot;</code>大概编译成如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token function-variable function">onInput</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        foo <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，当出于其他的目的希望暴露出组件的<code>value</code>props时，这仍然要求通过v-model绑定属性的组件需要使用value作为props传递。（译者注：两者相冲突了）</p>`,6),f=a("code",null,"model",-1),_=a("code",null,"v-model",-1),y=a("code",null,"v-model",-1),x=a("code",null,"v-bind.sync",-1),q=a("code",null,"v-model",-1),j=a("code",null,"v-bind.sync",-1),V=o(`<h2 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计" aria-hidden="true">#</a> 详细设计</h2><p>在3.0中，<code>model</code>选项将会被移除。组件上的<code>v-model=&quot;foo&quot;</code>（无参数形式）将会编译成如下格式：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">modelValue</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:modelValue&#39;</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>foo <span class="token operator">=</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),C=a("code",null,"v-model",-1),w=a("code",null,"modelValue",-1),N=a("code",null,'"update:modelValu"',-1),E=a("p",null,[n("props和事件的默认编译前缀"),a("code",null,"model"),n("可以避免与其他props和事件冲突。")],-1),I=a("code",null,"v-model",-1),A=a("code",null,'v-model:value="foo"',-1),M=o(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:value&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>foo <span class="token operator">=</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个用例中，子组件需要接收一个名为<code>value</code>的props并且抛出<code>update:value</code>的事件来同步值。</p><p>注意的是这支持在同一个组件上绑定多个<code>v-model</code>，同步每个不同的props并不需要组件中额外的选项：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>InviteeForm
    v<span class="token operator">-</span>model<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">&quot;inviteeName&quot;</span>
    v<span class="token operator">-</span>model<span class="token operator">:</span>email<span class="token operator">=</span><span class="token string">&quot;inviteeEmail&quot;</span>
<span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="处理修饰符" tabindex="-1"><a class="header-anchor" href="#处理修饰符" aria-hidden="true">#</a> 处理修饰符</h3><p>在2.x中，我们通过硬编码支持组件上<code>v-model</code>的修饰符。但是，如果组件支持自定义修饰符是很有用的。在v3中，添加在组件<code>v-model</code> 上的修饰符将会通过<code>modelModifiers</code>提供到组件上。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>Comp v<span class="token operator">-</span>model<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将会被编译为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">modelValue</span><span class="token operator">:</span> text<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:modelValue&#39;</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>text <span class="token operator">=</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">modelModifiers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于带参数的<code>v-model</code>，生成的修饰符名称为<code>arg+&#39;Modifiers&#39;</code>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>Comp
    v<span class="token operator">-</span>model<span class="token operator">:</span>foo<span class="token punctuation">.</span>trim<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
    v<span class="token operator">-</span>model<span class="token operator">:</span>bar<span class="token punctuation">.</span>number<span class="token operator">=</span><span class="token string">&quot;number&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将会被编译为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> text<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:foo&#39;</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>text <span class="token operator">=</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fooModifiers</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">trim</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:bar&#39;</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>bar <span class="token operator">=</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">barModifiers</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在原生元素上使用" tabindex="-1"><a class="header-anchor" href="#在原生元素上使用" aria-hidden="true">#</a> 在原生元素上使用</h3><p>另一方面，<code>v-model</code>可以在原生元素上使用。在2.x中，编译器根据不同的元素类型上的<code>v-model</code> 生成不同的代码。例如，它在<code>&lt;input type=&quot;text&quot;&gt;</code>和<code>&lt;input type=&quot;checkbox&quot;&gt;</code>上会编译出不同的代码。但是，这个策略并不能很好的处理动态元素和input类型：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dynamicType<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器无法在编译期猜测出正确的props/event组合形式，因此需要非常冗余的代码来覆盖可能用例。</p><p>在3.0中，在原生元素上的v-model会像组件上的一样被编译出确切的输出。例如，<code>&lt;input v-model=&quot;foo&quot;&gt;</code>会被编译为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;input&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">modelValue</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token string-property property">&#39;onUpdate:modelValue&#39;</span><span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        foo <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>负责为web平台打补丁的模块将会动态的决定如何实际应用它们。这尽可能的让编译器输出最少的冗余代码。</p><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><p>TODO</p><h2 id="可选的方案" tabindex="-1"><a class="header-anchor" href="#可选的方案" aria-hidden="true">#</a> 可选的方案</h2><p>N/A</p><h2 id="采取的策略" tabindex="-1"><a class="header-anchor" href="#采取的策略" aria-hidden="true">#</a> 采取的策略</h2><p>TODO</p><h2 id="还未解决的问题" tabindex="-1"><a class="header-anchor" href="#还未解决的问题" aria-hidden="true">#</a> 还未解决的问题</h2><h3 id="在自定义元素上使用" tabindex="-1"><a class="header-anchor" href="#在自定义元素上使用" aria-hidden="true">#</a> 在自定义元素上使用</h3>`,28),U={href:"https://github.com/vuejs/vue/issues/7830",target:"_blank",rel:"nofollow noopener noreferrer"},L=o(`<p>在2.x中，在原生自定义元素上使用<code>v-model</code>很困难（译者注：例如web component），因为编译器无法从普通的Vue组件中分辨出原生自定义元素（<code>Vue.config.ignoredElements</code> 仅在运行时生效）。在自定义元素上使用v-model将会导致：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-input</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.x编译器将会根据Vue组件生成代码而不是原生默认<code>value/input</code>。</p><p>在3.0中，无论是原生元素还是Vue组件，编译器都将一定会生成相同的代码，并且原生自定义元素将会作为原生元素被合适的处理。</p><p>其余的问题是第三方自定义元素会有未知的props/event组合，并且不一定遵循Vue同步事件的命名约定。例如如果一个自定义元素期望像checkbox那样工作，Vue并没有信息确定绑定哪个属性合适或者监听哪个事件合适。另一种处理这种情况的可能的方式是使用<code>type</code> 属性作为提醒：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-input</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这告诉Vue绑定<code>v-model</code>时，使用<code>&lt;input type=&quot;checkbox&quot;&gt;</code>相同的逻辑，使用<code>checked</code>作为<code>props</code>并且使用<code>change</code>作为事件。</p><p>如果这个自定义元素的行为并不像现存的<code>input</code>类型，那么可能更好的方式是显式使用<code>v-bind</code>和<code>v-on</code>。</p><div class="custom-container tip"><p class="custom-container-title">译者注</p><p>存在的问题主要指两种情况：</p><ol><li>web component自定义元素</li><li>跨平台框架基于原生元素的第二次封装</li></ol><p>在v2中，Vue对待在组件和原生元素上的v-model是两套逻辑：</p><ul><li>当是组件时，Vue会直接抛出值，并且在处理事件时是在<code>$event</code>中取值。</li><li>当是原生元素时，Vue会从<code>$event.target.value</code>取值。</li></ul><p>所以在判断逻辑上，除了原生的input组件都会走组件的逻辑来处理<code>v-model</code> 值，但是在编译期Vue并不能判断元素是否为组件或者是否为元素。虽然<code>Vue.config.ignoredElements</code> 是可以忽略组件的判断，直接走原生元素的判断逻辑。但是<code>Vue.config.ignoredElements</code> 是仅运行时生效的选项，所以导致了原生元素从<code>$event</code>中取值，与预期的行为不一致。</p></div>`,9);function O(R,T){const e=p("RouterLink"),l=p("ExternalLinkIcon");return i(),r("div",null,[d,v,k,a("p",null,[n("这次变动建立在RFC"),s(e,{to:"/vue-ecology/rfcs/0005-replace-v-bind-sync-with-v-model-argument.html"},{default:t(()=>[n("#5")]),_:1}),n("上（用"),m,n("参数替换"),h,n(" 的"),b,n("修饰符）。")]),g,a("p",null,[n("在2.2中，我们在组件选项中引入了"),f,n("选项来自定义"),_,n("需要的prop以及事件。但是，这仍然只允许在组件上使用一个"),y,n(" 。在实践中，我们看到一些组件需要同步许多属性的值，并且这些属性必须通过"),x,n(" 来同步值。我们注意到，从根本上来讲"),q,n(" 和"),j,n(" 是在做同样的事情，并且可以通过允许v-model接收参数来合并到同一个结构中（像"),s(e,{to:"/vue-ecology/rfcs/0005-replace-v-bind-sync-with-v-model-argument.html"},{default:t(()=>[n("#5")]),_:1}),n(" 提议的那样）。")]),V,a("p",null,[n("如果一个组件想要支持无参数形式的"),C,n("，它应该声明一个名称为"),w,n(" 的props。为了同步值回父组件，子组件应该抛出一个名为"),N,n(" 的事件（参考"),s(e,{to:"/vue-ecology/rfcs/0008-render-function-api-change.html"},{default:t(()=>[n("render函数API变更")]),_:1}),n("中的新VNode数据结构中的更多细节）。")]),E,a("p",null,[s(e,{to:"/vue-ecology/rfcs/0005-replace-v-bind-sync-with-v-model-argument.html"},{default:t(()=>[n("RFC 5#")]),_:1}),n(" 建议支持v-model接收参数的能力。使用这个参数时，意味着"),I,n("应该绑定一个props。"),A,n("被编译成：")]),M,a("p",null,[a("a",U,[n("issue#7830"),s(l)])]),L])}const F=c(u,[["render",O],["__file","0011-v-model-api-change.html.vue"]]);export{F as default};
