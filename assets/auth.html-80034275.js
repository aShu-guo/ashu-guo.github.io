import{_ as t,r,o as c,c as i,a as n,d as e,e as o,b as a}from"./app-a46f6870.js";const p="/imgs/server/jwt-auth-refresh.png",d="/imgs/server/refresh-token-rotation.png",l={},u=a(`<h1 id="认证模块" tabindex="-1"><a class="header-anchor" href="#认证模块" aria-hidden="true">#</a> 认证模块</h1><p>项目的认证模块是基于token的jwt模式。jwt模式是用户访问服务端受限资源的一种策略</p><h2 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> jwt</h2><p>如果之前使用JWT模式，并且存储token到localStorage中的校验登录态，则需要调整为存入Cookie中。</p><p>JWT模式中的token使用方式：</p><ul><li>登录用户用账号、密码换取的token，在客户端保存时既可以放在<code>Cookie</code>中，又可以放在<code>localStorage</code>中</li><li>token中间用<code>.</code>隔开分成3段，<code>Header.Payload.Signature</code>存放有关token类型、加密方式、签发方式等信息</li><li>再次请求接口时，需要将token带回服务端。既可以将token放在<code>Cookie</code>中（会存在跨域），又可以放在请求头的<code>Authorization</code>中</li></ul><p>缺点：</p><ul><li>token一旦签发，有效期只与失效时间有关，除非服务端添加额外的逻辑。</li><li>默认不加密，需要传输敏感数据时则应加密</li></ul><h2 id="refresh-token" tabindex="-1"><a class="header-anchor" href="#refresh-token" aria-hidden="true">#</a> refresh token</h2><p>为了更好的用户体验，不会频繁跳入登录页面。所以在认证之后，也需要响应的提供刷新策略。其中刷新token有多种策略，可以大致分为<code>服务端主动刷新</code> 和<code>客户端主动刷新</code>，当然也有另外一种并不支持的方式：尽可能延长token有效时间，但是这<code>非常危险⚠️</code></p><h3 id="服务端主动刷新" tabindex="-1"><a class="header-anchor" href="#服务端主动刷新" aria-hidden="true">#</a> 服务端主动刷新</h3><p>服务端在用户访问时判断token是否有效以及剩余有效期，无效或者剩余时间不长，则返回新token给客户端。但是服务端每次都前置判断接口请求的<code>access_token</code> 是否有效</p><p>可以在guide或者middleware上添加检查<code>token是否有效以及剩余有效期不足</code>的判断逻辑：</p><ol><li>token有效，放行</li><li>token失效，服务端重新生成token并在本次请求中返回给客户端，客户端需要判断是否为新的token，如果是新token则使用</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// server</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExpire</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">access_token</span><span class="token operator">:</span> <span class="token function">genToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// client</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">!==</span> newToken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    header<span class="token punctuation">[</span><span class="token string">&#39;Authorization&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> newToken
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存在安全隐患：用户一旦登录之后就永久认证了，效果等价于用户拥有一个无限有效时长的token；而且压力都集中在服务端。故不建议在服务端主动刷新token</p><h3 id="客户端主动刷新" tabindex="-1"><a class="header-anchor" href="#客户端主动刷新" aria-hidden="true">#</a> 客户端主动刷新</h3><p>客户端自行判断token是否有效，无效时需要主动请求刷新token接口，注意<code>refresh</code>接口只能用于刷新token，不能访问其他资源。</p><p>既然需要客户端判断，那么在登录时需要保存token以及有效时长，将token存放到状态管理框架（ex: pinia）中，并且持久化到<code>localStorage</code>中。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;token&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xxxx&quot;</span><span class="token punctuation">,</span>
  <span class="token comment">// 生成token时的时间戳</span>
  <span class="token property">&quot;start&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token comment">// 过期时间为10分钟</span>
  <span class="token property">&quot;expire&quot;</span><span class="token operator">:</span> <span class="token number">600000</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断逻辑需要放在：</p><ul><li>axios的request interceptor</li><li>路由守卫</li></ul><p>为什么也要放在路由守卫中呢？</p><p>因为导航到新页面的钩子函数中会存在接口请求，那么既然token已经失效，就没必要再去请求接口。而且对应的响应拦截器中的错误提醒：<code>this.$message.error(message)</code> 会被触发多次。</p><p>但是客户端存储的token有效时长可能会与服务端不一致，存在10ms～100ms的延迟，这与网络情况有关。</p><p>用户在登录时返回两个有效时长不同的token，其中<code>refresh_token</code>有效期较长：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;access_token&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xxxx&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;refresh_token&quot;</span><span class="token operator">:</span> <span class="token string">&quot;yyyy&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设<code>access_token</code>有效时长为10分钟，而<code>refresh_token</code>有效时长为1天。那么在客户端请求到服务端时，如果<code>access_token</code> 失效则需要拿着<code>refresh_token</code>去服务端换取新的token。</p><p>但是如果用户登录之后，没有与客户端交互（ex：闲置隐藏了页面或者去玩游戏了），<code>refresh_token</code>与<code>access_token</code>双双失效导致用户需要重新登录。</p><p><img src="`+p+'" alt="img.png"></p><h4 id="轮换refresh-token" tabindex="-1"><a class="header-anchor" href="#轮换refresh-token" aria-hidden="true">#</a> 轮换refresh token</h4><p>由于<code>refresh token</code>有效时间足够长，那么被泄露时导致的安全问题也是严重的。</p><p>攻击者在<code>access_token</code>失效时，通过<code>refresh token</code>重新获取<code>access_token</code>直到<code>refresh token</code>失效。</p>',33),k=n("code",null,"refresh token",-1),h={href:"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-05#section-8",target:"_blank",rel:"nofollow noopener noreferrer"},m=a('<p>举个🌰：</p><p>假如我们有一个应用：mobile app，服务端提供一下认证链路：</p><ol><li>用户登录，获取一对token：<code>access_token</code>和<code>refresh token</code>，其中<code>access_token</code>有效时长为10分钟，<code>refresh token</code>有效时长为2年</li><li>10分钟后，<code>access_token</code>失效，用户与服务端交互时需要首先刷新token，请求<code>refresh</code>接口，再次获取一对<code>access_token</code> 和<code>refresh token</code></li><li>服务端销毁旧<code>refresh token</code></li></ol><p><img src="'+d+'" alt="img.png"></p><h2 id="注销" tabindex="-1"><a class="header-anchor" href="#注销" aria-hidden="true">#</a> 注销</h2><p>jwt token是无状态的，只能在有效期到了才会被销毁，除此之外是无法手动销毁的。那么jwt模式下用户是如何注销的呢？</p><p>用户注销时，即使客户端清除了token，在下次与服务端交互时会提示：<code>未认证</code>。但是token如果还在有效期，它依然可以用来与服务端交互。</p><p>既然无法销毁，那么我们就把非法的token存起来，放到一个<code>&quot;黑名单&quot;</code>中，用redis存储再合适不过了。</p><h2 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2><p>参考：</p>',10),f={href:"https://learnku.com/articles/7264/using-jwt-auth-to-implement-api-user-authentication-and-painless-refresh-access-token",target:"_blank",rel:"nofollow noopener noreferrer"},v={href:"https://katifrantz.com/the-ultimate-guide-to-jwt-server-side-authentication-with-refresh-tokens",target:"_blank",rel:"nofollow noopener noreferrer"},_={href:"https://security.stackexchange.com/questions/119371/is-refreshing-an-expired-jwt-token-a-good-strategy",target:"_blank",rel:"nofollow noopener noreferrer"},g={href:"https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html",target:"_blank",rel:"nofollow noopener noreferrer"};function b(x,w){const s=r("ExternalLinkIcon");return c(),i("div",null,[u,n("p",null,[e("所以应该轮换"),k,e(" ，限制它只能使用一次，这也是互联网工程任务组推荐的"),n("a",h,[e("策略"),o(s)]),e("。")]),m,n("p",null,[e("【1】"),n("a",f,[e("使用 Jwt-Auth 实现 API 用户认证以及无痛刷新访问令牌"),o(s)])]),n("p",null,[e("【2】"),n("a",v,[e("The Ultimate Guide to JWT server-side auth (with refresh tokens)"),o(s)])]),n("p",null,[e("【3】"),n("a",_,[e("Is refreshing an expired JWT token a good strategy?"),o(s)])]),n("p",null,[e("【4】"),n("a",g,[e("JSON Web Token 入门教程"),o(s)])])])}const q=t(l,[["render",b],["__file","auth.html.vue"]]);export{q as default};
