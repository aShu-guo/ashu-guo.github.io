import{_ as n,o as s,c as a,b as t}from"./app-a46f6870.js";const o={},p=t(`<h1 id="统一slot" tabindex="-1"><a class="header-anchor" href="#统一slot" aria-hidden="true">#</a> 统一slot</h1><h2 id="概要" tabindex="-1"><a class="header-anchor" href="#概要" aria-hidden="true">#</a> 概要</h2><p>统一普通slot以及作用域slot，在Vue3中都作为slot存在。</p><h2 id="动机" tabindex="-1"><a class="header-anchor" href="#动机" aria-hidden="true">#</a> 动机</h2><ul><li>存在普通插槽和作用域插槽两种形式的原因是：作用域插槽是后来新增的，并且在Vue2.x中是不同的实现方式。但是，在技术上是没必要区分的。统一这两种形式可以简化slot相关的概念。</li><li>使用render函数构建的组件库作者不再需要同时处理<code>$slots</code>和<code>$slotScoped</code>。</li><li>将所有slot编译成函数对于大型组件树来说是可以提高性能的。</li></ul><p>引用2.6版本的公告：</p><blockquote><p>普通插槽会在父组件的渲染生命周期中渲染。当slot中的依赖发生改变时，父组件和子组件都会重新渲染。 从另一方面来说，作用域插槽会被编译进函数中并且在子组件的渲染生命周期中渲染。这意味着， 作用域插槽中的数据依赖都是由子组件收集，可以更加精准的更新。在2.6中，我们引入了一种优化方式：进一步确保父组件中的依赖发生改变时只影响他自己，如果子组件作为作用域插槽使用，那么则不会触发重新渲染。</p></blockquote><h2 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计" aria-hidden="true">#</a> 详细设计</h2><p>设计两个部分：</p><ul><li>语法统一（在2.6中作为<code>v-slot</code>发布）</li><li>实现上统一：编译slot成函数。 <ul><li><code>this.$slots</code>将slot作为函数暴露出去；</li><li>移除<code>this.$scopedSlots</code></li><li>在2.x中，所有使用<code>v-slot</code>指令的slot在内部都会编译成函数。<code>this.$scopedSlots</code>也会代理到普通slot上并且将插槽作为函数暴露出。</li></ul></li></ul><h2 id="在render函数中使用" tabindex="-1"><a class="header-anchor" href="#在render函数中使用" aria-hidden="true">#</a> 在render函数中使用</h2><p>现存render函数的使用方式都会得到支持。当传递子节点到父组件时，VNodes和函数都会支持的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 等价于:</span>
<span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>Comp</code>内部，这两种用例中<code>this.$slots.default</code>都是函数类型，并且返回相同的VNodes。但是，第二种用例的性能更好，因为this.msg只会注册到在子组件的依赖中。</p><p>具名插槽的使用方式发生了改变--不再需要特别指定<code>slot</code>属性在节点上，只需要作为第3个参数传递即可</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 2.x</span>
<span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">slot</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">slot</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 3.0</span>
<span class="token comment">// Note the \`null\` is required to avoid the slots object being mistaken</span>
<span class="token comment">// for props.</span>
<span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="进一步的优化" tabindex="-1"><a class="header-anchor" href="#进一步的优化" aria-hidden="true">#</a> 进一步的优化</h3><p>需要注意的是当父组件更新时，<code>Comp</code>经常被迫更新。对于render函数，因为没有编译步骤，Vue并没有足够的信息判断<code>slots</code>是否已经更改。</p><p>编译template时，可以通过检查<code>v-slot</code>后编译为函数，但是在render函数中并不能自动的判断出。我们也可以在 JSX babel 插件中执行类似的优化。但是对于直接写render函数的用户来说，他们需要在性能敏感的用例中手动优化。</p><p>标注slot在父组件更新时，不会触发子组件更新：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">$stable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="采取的策略" tabindex="-1"><a class="header-anchor" href="#采取的策略" aria-hidden="true">#</a> 采取的策略</h2><p>这个变更中重要的部分已经在2.6版本中发布。遗留下来没做的事情是将<code>this.$scopedSlots</code> 从API中移除。在实践上，2.6中的<code>this.$scopedSlots</code>工作原理类似3.0中的<code>this.$slots</code>，因此迁移可以分为两部：</p><ol><li>在2.x代码库中使用<code>this.$scopedSlots</code></li><li>在3.x版本中使用<code>this.$slots</code>全局替换<code>this.$scopedSlots</code></li></ol>`,24),e=[p];function c(i,l){return s(),a("div",null,e)}const d=n(o,[["render",c],["__file","0006-slots-unification.html.vue"]]);export{d as default};
