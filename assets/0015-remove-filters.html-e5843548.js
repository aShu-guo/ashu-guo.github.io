import{_ as e,o as a,c as s,b as r}from"./app-a46f6870.js";const i={},n=r(`<h1 id="移除filter" tabindex="-1"><a class="header-anchor" href="#移除filter" aria-hidden="true">#</a> 移除filter</h1><h2 id="概要" tabindex="-1"><a class="header-anchor" href="#概要" aria-hidden="true">#</a> 概要</h2><p>移除filters支持</p><h2 id="基础用例" tabindex="-1"><a class="header-anchor" href="#基础用例" aria-hidden="true">#</a> 基础用例</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;!-- before --&gt;
{{ msg | format }}

&lt;!-- after --&gt;
{{ format(msg) }}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="动机" tabindex="-1"><a class="header-anchor" href="#动机" aria-hidden="true">#</a> 动机</h2><ul><li>filter函数提供的能力可以通过调用method或者computed来实现，因此它更多的是提供语法价值而不是实用价值</li><li>filters必须使用自定义语法，这并是不纯js（增加了学习成本和实现成本）。事实上，这也与js自身的或运算符（<code>|</code>）相冲突，导致在解析时变得麻烦。</li><li>filters对于IDE的template支持也造成了额外的复杂性（因为它们并不是js）</li></ul><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><ul><li>当使用多个filter时，读起来相对于调用method更容易理解</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>msg | uppercase | reverse | pluralize
// vs
pluralize(reverse(uppercase(msg)))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在实践中我们发现很少会有使用多个过滤器，所以丢失部分可读性似乎是可以接受的。</p><ul><li>与全局注册的过滤器相比，单独导入或定义方法可能更像样板文件。然而，全局过滤器与在<code>Vue.prototype</code> 上注册特别命名的全局<code>helper</code>没有根本区别。这种全局注册伴随着权衡：它们使代码依赖关系不那么明确，也使它们难以提供类型推断。</li></ul><h2 id="可选的方案" tabindex="-1"><a class="header-anchor" href="#可选的方案" aria-hidden="true">#</a> 可选的方案</h2><p>在js中有个添加pipeline操作符的第1阶段提案，提供了与filter大致相同的功能：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> transformedMsg <span class="token operator">=</span> msg <span class="token operator">|</span><span class="token operator">&gt;</span> uppercase <span class="token operator">|</span><span class="token operator">&gt;</span> reverse <span class="token operator">|</span><span class="token operator">&gt;</span> pluralize

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>考虑到这个提案最终落地的可能性，对于框架而言例如Vue并不应该提供类似的可选方案（尤其是与现存js语法相冲突）。</p><p>这个提案仍然还在第1阶段，而且有很长时间没有更新，因此并不能确定它什么时候落地，或者落地之后是否会像现在设计的那样。对于Vue而言，选择它作为正式API的一部分是有风险的，因为如果它发生了变更我们也必须同步调整。</p><p>在Vue3中，模板语法是使用<code>@babel/parser</code>解析的，而且通过添加编译器选项中的<code>expressionPlugins</code> 提供对于pipeline操作符的在template中的支持（将会通过传递给<code>@babel/parser</code>作为它的<code>plugins</code> 选项）。注意Vue模板编译选项仅启用了语法解析（生成的render函数需要交给babel做进一步转换，这将会在新的基于 webpack 的设置中默认启用的）</p><h2 id="采取的策略" tabindex="-1"><a class="header-anchor" href="#采取的策略" aria-hidden="true">#</a> 采取的策略</h2><p>在2.x的兼容版本中仍然支持filters，并抛出警告提示渐进式迁移。</p>`,20),d=[n];function l(t,c){return a(),s("div",null,d)}const p=e(i,[["render",l],["__file","0015-remove-filters.html.vue"]]);export{p as default};
