import{_ as n,o as a,c as s,b as e}from"./app-a46f6870.js";const t={},p=e(`<h1 id="异步函数式api变更" tabindex="-1"><a class="header-anchor" href="#异步函数式api变更" aria-hidden="true">#</a> 异步函数式API变更</h1><h2 id="概要" tabindex="-1"><a class="header-anchor" href="#概要" aria-hidden="true">#</a> 概要</h2><ul><li>函数式组件必须写成纯函数形式 <ul><li>移除<code>{ functional: true }</code>选项</li><li>不再支持<code>&lt;template functional&gt;</code></li></ul></li><li>异步函数式组件必须通过指定的API创建</li></ul><h2 id="基本示例" tabindex="-1"><a class="header-anchor" href="#基本示例" aria-hidden="true">#</a> 基本示例</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>h<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> <span class="token function-variable function">FunctionalComp</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>defineAsyncComponent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> AsyncComp <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./Foo.vue&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="动机" tabindex="-1"><a class="header-anchor" href="#动机" aria-hidden="true">#</a> 动机</h2><h3 id="简化函数式组件" tabindex="-1"><a class="header-anchor" href="#简化函数式组件" aria-hidden="true">#</a> 简化函数式组件</h3><p>在2.x中，函数式组件必须通过以下格式创建：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> FunctionalComp <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">functional</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这会有以下问题：</p><ul><li>当组件不需要任何选项，仅需要render函数时，也必须传递<code>functional: true</code></li><li>一些选项支持（<code>props</code>和<code>inject</code>），但是另外一些不支持（<code>components</code> ）。但是，用户经常认为所有的选项都会支持，因为目前的函数式组件看起来像普通有状态的组件（尤其是当他们在SFC中使用<code>&lt;template functional&gt;</code> 时）</li></ul><p>另外一方面的原因是，我们注意到用户使用函数式组件仅仅是因为它的性能。例如：在SFC中使用<code>&lt;template functional&gt;</code> 时，请求实现者在组件中支持更多有状态的选项。但是，我并不认为这是我们需要花时间研究的事情。</p><p>在v3中，有状态组件和无状态组件之间的性能差异将会变得更小，而且在一些用例中没有任何差别。因此，不再有仅仅为了性能而使用函数式组件的强烈动机，这也证明支持 <code>&lt;template functional&gt;</code> 的维护成本是不合理的。在v3中的函数式组件应该出于使用简单的目的去使用，而不是性能。</p><h2 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计" aria-hidden="true">#</a> 详细设计</h2><p>在3.x中，我们有意仅仅通过纯函数支持函数式组件：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>h<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> <span class="token function-variable function">FunctionalComp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">{</span>slots<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> emit<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>移除<code>functional</code>选项，不再支持对象格式的<code>{ functional: true }</code>。</li><li>SFCs不再支持<code>&lt;template functional&gt;</code>-如果你想要使用组件中的任意选项而不单是一个函数，那么请使用普通组件。</li><li>函数入参发生改变： <ul><li><code>h</code>现在通过全局导出</li><li>函数接收两个参数：<code>props</code>和一个暴露出<code>slots</code>, <code>attrs</code>和<code>emit</code>属性的上下文对象。等价于有状态组件中的带<code>$</code>属性的等价物。</li></ul></li></ul><h3 id="与旧语法之间的比较" tabindex="-1"><a class="header-anchor" href="#与旧语法之间的比较" aria-hidden="true">#</a> 与旧语法之间的比较</h3><p>新的参数列表需要完全具备可替换当前函数式组件参数的能力：</p><ul><li><code>props</code>和<code>slots</code>值与旧语法保持一；</li><li><code>data</code>和<code>children</code>不再是必须的（使用props和slot即可）；</li><li><code>listeners</code>将会被包含在<code>attrs</code>中；</li><li><code>injections</code>将会被新API<code>inject</code>替换（组合式API的一部分）：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>inject<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>themeSymbol<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./ThemeProvider&#39;</span>

<span class="token keyword">const</span> <span class="token function-variable function">FunctionalComp</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>themeSymbol<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Using theme </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>theme<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将会移除<code>parent</code>的访问权限。这是一些内部用例的逃生舱 - 在用户侧，props和injections应该是首选。</li></ul><h3 id="可选的props声明" tabindex="-1"><a class="header-anchor" href="#可选的props声明" aria-hidden="true">#</a> 可选的props声明</h3><p>为了在简单用例中使用更加方便，在3.x中函数式组件中，props的声明不再是必须的：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>msg<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>Foo msg<span class="token operator">=</span><span class="token string">&quot;hello!&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不再需要明确的（explicit）props声明，第一个参数<code>props</code>将会包含所有通过父组件传递的属性。</p><h3 id="明确的props声明" tabindex="-1"><a class="header-anchor" href="#明确的props声明" aria-hidden="true">#</a> 明确的props声明</h3><p>需要明确的props声明时，可以将props与函数本身联系起来：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">FunctionalComp</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>props<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

FunctionalComp<span class="token punctuation">.</span>props <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> String
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="异步组件创建" tabindex="-1"><a class="header-anchor" href="#异步组件创建" aria-hidden="true">#</a> 异步组件创建</h3><p>还在被讨论中（译者注：在本RFC实现的同时，也在讨论异步组件创建的PR，并且在翻译本文之前已经实现）。</p><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><ul><li>迁移成本</li></ul><h2 id="可替代方案" tabindex="-1"><a class="header-anchor" href="#可替代方案" aria-hidden="true">#</a> 可替代方案</h2><p>N/A</p><h2 id="采取的策略" tabindex="-1"><a class="header-anchor" href="#采取的策略" aria-hidden="true">#</a> 采取的策略</h2><ul><li>对于函数式组件，可以提供逐个迁移的兼容模式。</li><li>使用<code>&lt;template functional&gt;</code>的SFC应该被转换为普通SFC。</li></ul>`,39),o=[p];function c(i,l){return a(),s("div",null,o)}const u=n(t,[["render",c],["__file","0007-functional-async-api-change.html.vue"]]);export{u as default};
