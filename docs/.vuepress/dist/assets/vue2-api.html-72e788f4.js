import{_ as s,p as a,q as e,a1 as n}from"./framework-1443a5b1.js";const t={},r=n(`<blockquote><h4 id="listener-attrs" tabindex="-1"><a class="header-anchor" href="#listener-attrs" aria-hidden="true">#</a> $listener &amp; $attrs</h4></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1.</span>使用场景，存在这样一个逻辑：爷组件<span class="token operator">-</span>父组件<span class="token operator">-</span>子组件
从爷组件中传递props到子组件，爷组件监听子组件事件

<span class="token number">2.</span>父组件可以通过$attrs传递非父组件中声明的props到子组件（$attrs不包含<span class="token keyword">class</span>，style），所以<span class="token string">&#39;注意&#39;</span>不要声明与子组件中重名的props
父组件可以通过$listener传递非native事件到子组件

<span class="token number">3</span><span class="token punctuation">.</span>demo
<span class="token operator">&lt;</span>ElBtnWrapper type<span class="token operator">=</span><span class="token string">&quot;ghost&quot;</span> size<span class="token operator">=</span><span class="token string">&quot;large&quot;</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;name&quot;</span>  @click<span class="token operator">=</span><span class="token string">&quot;demoHandler&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ElBtnWrapper<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1.</span>爷组件希望传递props到子组件，爷组件希望监听子组件事件
<span class="token number">2.</span>对组件二次封装，不希望传递多个props

如果不使用$attrs、$listener
在父组件中props接收爷组件中传入的属性，有需要在父组件中监听子组件的事件并$emit对应的事件以及参数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h4></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div><blockquote><h4 id="inheritattrs" tabindex="-1"><a class="header-anchor" href="#inheritattrs" aria-hidden="true">#</a> inheritAttrs</h4></blockquote><p><code>attrs：未定义的props以及html的属性构成的并集</code></p><p>默认为true：传入attrs会绑定到template的根节点上；重名则覆盖，class、styles则合并</p><p>false：传入attrs不会绑定到template的根节点上；重名不会覆盖，class、styles则合并</p><p><strong>确定未定义的attrs的行为</strong></p><p><code>但是$attrs可以突破 inheritAttrs:false 的限制，将未定义的attrs通过v-bind绑定在非根元素上 </code></p><blockquote><h4 id="watch" tabindex="-1"><a class="header-anchor" href="#watch" aria-hidden="true">#</a> watch</h4></blockquote><p>设置为立即执行时，被设置了<code>v-if</code>和<code>v-show</code>组件中的watch执行顺序不同</p><p>v-if：符合条件后重新挂载，后执行watch中的逻辑</p><p>v-show：符合条件后visible设置为可见，但是watch立执行的逻辑是在挂载父组件时便执行了</p>`,16),i=[r];function o(l,p){return a(),e("div",null,i)}const d=s(t,[["render",o],["__file","vue2-api.html.vue"]]);export{d as default};
